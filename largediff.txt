dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;
	   
	   dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;dfda2f
static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)
{
	int error = 0;
	khiter_t pos;
	git_submodule *sm = NULL;
	pos = git_strmap_lookup_index(map, name);
	if (git_strmap_valid_index(map, pos)) {
		sm = git_strmap_value_at(map, pos);
		goto done;
	}
	/* if the submodule doesn't exist yet in the map, create it */
	if ((error = submodule_alloc(&sm, repo, name)) < 0)
		return error;
	pos = kh_put(str, map, sm->name, &error);
	/* nobody can beat us to adding it */
	assert(error != 0);
	if (error < 0) {
		git_submodule_free(sm);
		return error;
	}
	git_strmap_set_value_at(map, pos, sm);
done:
	GIT_REFCOUNT_INC(sm);
	*out = sm;
	return 0;
}
f17525
static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)
dfda2f
{
       int error;
       git_iterator *i;